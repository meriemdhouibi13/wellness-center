<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wellness Center - Developer Console</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
      color: #333;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    .header {
      background: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      margin-bottom: 20px;
      text-align: center;
    }

    .header h1 {
      color: #667eea;
      margin-bottom: 10px;
    }

    .header p {
      color: #666;
      font-size: 14px;
    }

    .status {
      background: white;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .status.connected {
      border-left: 4px solid #10b981;
    }

    .status.disconnected {
      border-left: 4px solid #ef4444;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
    }

    .card {
      background: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    .card h2 {
      font-size: 18px;
      margin-bottom: 15px;
      color: #667eea;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .card-icon {
      font-size: 24px;
    }

    .button {
      background: #667eea;
      color: white;
      border: none;
      padding: 12px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      width: 100%;
      margin-top: 10px;
      transition: all 0.2s;
    }

    .button:hover {
      background: #5568d3;
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
    }

    .button:active {
      transform: translateY(0);
    }

    .button:disabled {
      background: #9ca3af;
      cursor: not-allowed;
      opacity: 0.6;
      transform: none;
      box-shadow: none;
    }

    .button:disabled:hover {
      background: #9ca3af;
      transform: none;
      box-shadow: none;
    }

    .button.secondary {
      background: #10b981;
    }

    .button.secondary:hover {
      background: #059669;
    }

    .button.secondary:disabled {
      background: #9ca3af;
    }

    .button.danger {
      background: #ef4444;
    }

    .button.danger:hover {
      background: #dc2626;
    }

    .button.danger:disabled {
      background: #9ca3af;
    }

    .input-group {
      margin-top: 10px;
    }

    .input-group label {
      display: block;
      font-size: 12px;
      color: #666;
      margin-bottom: 5px;
      font-weight: 600;
    }

    .input-group input,
    .input-group select {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 14px;
      margin-bottom: 10px;
    }

    .log {
      background: #1e293b;
      color: #10b981;
      padding: 15px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      max-height: 300px;
      overflow-y: auto;
      margin-top: 10px;
    }

    .log-entry {
      margin-bottom: 5px;
      padding: 5px;
      border-left: 2px solid #10b981;
      padding-left: 10px;
    }

    .log-entry.error {
      border-left-color: #ef4444;
      color: #ef4444;
    }

    .log-entry.info {
      border-left-color: #3b82f6;
      color: #3b82f6;
    }

    .timestamp {
      color: #64748b;
      font-size: 11px;
    }

    .stats {
      display: flex;
      justify-content: space-around;
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid #e5e7eb;
    }

    .stat {
      text-align: center;
    }

    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #667eea;
    }

    .stat-label {
      font-size: 12px;
      color: #666;
      margin-top: 5px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>🏋️ Wellness Center Developer Console</h1>
      <p>Manual event triggers for demo and testing</p>
    </div>

    <div class="status disconnected" id="connectionStatus">
      <strong>Status:</strong> Connecting to Firebase...
    </div>

    <div class="grid">
      <!-- Equipment Control -->
      <div class="card">
        <h2><span class="card-icon">🏃</span> Equipment Control</h2>
        <div class="input-group">
          <label>Equipment ID</label>
          <select id="equipmentSelect" onchange="updateButtonStates()">
            <option value="">Loading equipment...</option>
          </select>
        </div>
        <button id="startSessionBtn" class="button secondary" onclick="startEquipmentSession()">▶️ Start Session</button>
        <button id="endSessionBtn" class="button danger" onclick="endEquipmentSession()">⏹️ End Session</button>
        <button id="reportMalfunctionBtn" class="button danger" onclick="reportMalfunction()">⚠️ Report Malfunction</button>
        <button id="fixMalfunctionBtn" class="button" onclick="fixMalfunction()">🔧 Fix Malfunction</button>
        <button id="markBrokenBtn" class="button danger" onclick="markAsBroken()">❌ Mark as Broken</button>
        <button id="fixBrokenBtn" class="button" onclick="fixBrokenMachine()">✅ Fix Broken Machine</button>
      </div>

      <!-- User Workout Sessions -->
      <div class="card">
        <h2><span class="card-icon">📊</span> Workout Sessions</h2>
        <div class="input-group">
          <label>User ID (Firebase Auth UID)</label>
          <input type="text" id="sessionUserId" placeholder="Firebase UID">
        </div>
        <div class="input-group">
          <label>Duration (minutes)</label>
          <input type="number" id="sessionDuration" placeholder="30" value="30">
        </div>
        <div class="input-group">
          <label>Equipment ID</label>
          <input type="text" id="sessionEquipment" placeholder="treadmill_1" value="treadmill_1">
        </div>
        <button class="button" onclick="addWorkoutSession()">➕ Add Single Session</button>
        <button class="button secondary" onclick="addWeekOfSessions()">📅 Add 7 Days of Sessions</button>
        <button class="button danger" onclick="clearUserSessions()">🗑️ Clear User Sessions</button>
      </div>

      <!-- Friends Management -->
      <div class="card">
        <h2><span class="card-icon">👥</span> Friends Management</h2>
        <div class="input-group">
          <label>User 1 Email (From)</label>
          <input type="text" id="friendUser1Email" placeholder="john@example.com">
        </div>
        <div class="input-group">
          <label>User 2 Email (To)</label>
          <input type="text" id="friendUser2Email" placeholder="jane@example.com">
        </div>
        <button class="button" onclick="createFriendRequest()">➕ Create Friend Request</button>
        <button class="button secondary" onclick="acceptAllPendingRequests()">✅ Accept All Pending (User 2)</button>
        <button class="button" onclick="makeFriendsDirectly()">🤝 Make Friends Directly</button>
        <button class="button danger" onclick="clearAllFriendData()">🗑️ Clear All Friend Data</button>
      </div>

      <!-- Activity Feed -->
      <div class="card">
        <h2><span class="card-icon">📱</span> Activity Feed</h2>
        <div class="input-group">
          <label>User ID</label>
          <input type="text" id="activityUserId" placeholder="Firebase UID">
        </div>
        <div class="input-group">
          <label>User Name</label>
          <input type="text" id="activityUserName" placeholder="John Doe">
        </div>
        <div class="input-group">
          <label>Activity Type</label>
          <select id="activityType">
            <option value="workout_completed">Workout Completed</option>
            <option value="achievement_earned">Achievement Earned</option>
            <option value="streak_milestone">Streak Milestone</option>
          </select>
        </div>
        <div class="input-group">
          <label>Description</label>
          <input type="text" id="activityDescription" placeholder="Completed a 30-min cardio session">
        </div>
        <div class="input-group">
          <label>Duration (minutes, optional)</label>
          <input type="number" id="activityDuration" placeholder="30">
        </div>
        <button class="button" onclick="postActivity()">📢 Post Activity</button>
        <button class="button secondary" onclick="generateSampleActivities()">🎲 Generate Sample Activities</button>
        <button class="button danger" onclick="clearAllActivities()">🗑️ Clear All Activities</button>
      </div>

      <!-- Quick Actions -->
      <div class="card">
        <h2><span class="card-icon">⚡</span> Quick Actions</h2>
        <button class="button" onclick="refreshEquipment()">🔄 Refresh Equipment List</button>
        <button class="button" onclick="toggleAllMachinesUsed()">🏢 Toggle All Machines as "Used"</button>
        <button class="button danger" onclick="clearAllSessions()">🧹 Clear All Sessions</button>
      </div>

      <!-- Database Stats -->
      <div class="card">
        <h2><span class="card-icon">📊</span> Database Stats</h2>
        <div class="stats">
          <div class="stat">
            <div class="stat-value" id="totalEquipment">-</div>
            <div class="stat-label">Equipment</div>
          </div>
          <div class="stat">
            <div class="stat-value" id="activeEquipment">-</div>
            <div class="stat-label">In Use</div>
          </div>
          <div class="stat">
            <div class="stat-value" id="availableEquipment">-</div>
            <div class="stat-label">Available</div>
          </div>
        </div>
        <button class="button" onclick="updateStats()">🔄 Refresh Stats</button>
      </div>
    </div>

    <!-- Activity Log -->
    <div class="card">
      <h2><span class="card-icon">📋</span> Activity Log</h2>
      <div class="log" id="activityLog">
        <div class="log-entry info">
          <span class="timestamp">[System]</span> Developer console initialized
        </div>
      </div>
    </div>
  </div>

  <!-- Firebase SDK -->
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
    import { getFirestore, collection, getDocs, doc, getDoc, updateDoc, setDoc, addDoc, deleteDoc, query, where, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';

    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyB8ll3C9NdZtqcDrXM-Bv9CglIN_7LRxdE",
      authDomain: "wellness-center-hackathon.firebaseapp.com",
      projectId: "wellness-center-hackathon",
      storageBucket: "wellness-center-hackathon.firebasestorage.app",
      messagingSenderId: "82202466445",
      appId: "1:82202466445:web:852d8363ef1f364957eac4",
      measurementId: "G-8K08F9TY1P"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // Make available globally
    window.db = db;
    window.firestoreModule = { collection, getDocs, doc, getDoc, updateDoc, setDoc, addDoc, deleteDoc, query, where, serverTimestamp };

    // Log function
    function log(message, type = 'success') {
      const logEl = document.getElementById('activityLog');
      const timestamp = new Date().toLocaleTimeString();
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.innerHTML = `<span class="timestamp">[${timestamp}]</span> ${message}`;
      logEl.appendChild(entry);
      logEl.scrollTop = logEl.scrollHeight;
    }

    window.log = log;

    // Update connection status
    document.getElementById('connectionStatus').className = 'status connected';
    document.getElementById('connectionStatus').innerHTML = '<strong>Status:</strong> ✅ Connected to Firebase';
    log('Connected to Firebase successfully', 'info');

    // Load equipment on startup
    loadEquipment();
    updateStats();

    // Load equipment list
    async function loadEquipment() {
      try {
        const { collection, getDocs } = window.firestoreModule;
        const equipmentRef = collection(window.db, 'equipment');
        const snapshot = await getDocs(equipmentRef);
        
        const select = document.getElementById('equipmentSelect');
        const currentValue = select.value; // Remember current selection
        
        select.innerHTML = '<option value="">-- No Equipment Selected --</option>';
        
        snapshot.forEach(doc => {
          const data = doc.data();
          const option = document.createElement('option');
          option.value = doc.id;
          option.textContent = `${data.name} (${data.type}) - ${data.status}`;
          select.appendChild(option);
        });
        
        // Restore previous selection if it still exists
        if (currentValue) {
          select.value = currentValue;
        }
        
        // Update button states after loading
        updateButtonStates();
        
        log(`Loaded ${snapshot.size} equipment items`);
      } catch (error) {
        log(`Error loading equipment: ${error.message}`, 'error');
      }
    }

    window.loadEquipment = loadEquipment;

    // Update button states based on selected equipment status
    async function updateButtonStates() {
      const equipmentId = document.getElementById('equipmentSelect').value;
      
      // Get button elements
      const startBtn = document.getElementById('startSessionBtn');
      const endBtn = document.getElementById('endSessionBtn');
      const reportMalfunctionBtn = document.getElementById('reportMalfunctionBtn');
      const fixMalfunctionBtn = document.getElementById('fixMalfunctionBtn');
      const markBrokenBtn = document.getElementById('markBrokenBtn');
      const fixBrokenBtn = document.getElementById('fixBrokenBtn');
      
      // If no equipment selected, disable all buttons
      if (!equipmentId) {
        startBtn.disabled = true;
        endBtn.disabled = true;
        reportMalfunctionBtn.disabled = true;
        fixMalfunctionBtn.disabled = true;
        markBrokenBtn.disabled = true;
        fixBrokenBtn.disabled = true;
        return;
      }
      
      try {
        const { doc, getDoc } = window.firestoreModule;
        const equipmentRef = doc(window.db, 'equipment', equipmentId);
        const equipmentDoc = await getDoc(equipmentRef);
        
        if (!equipmentDoc.exists()) {
          // Equipment not found, disable all buttons
          startBtn.disabled = true;
          endBtn.disabled = true;
          reportMalfunctionBtn.disabled = true;
          fixMalfunctionBtn.disabled = true;
          markBrokenBtn.disabled = true;
          fixBrokenBtn.disabled = true;
          return;
        }
        
        const data = equipmentDoc.data();
        const isBroken = data.status === 'broken';
        const isInUse = data.status === 'in_use';
        const isAvailable = data.status === 'available';
        const hasMalfunction = data.hasMalfunction === true;
        
        // If broken, only allow "Fix Broken Machine" button
        if (isBroken) {
          startBtn.disabled = true;
          endBtn.disabled = true;
          reportMalfunctionBtn.disabled = true;
          fixMalfunctionBtn.disabled = true;
          markBrokenBtn.disabled = true;
          fixBrokenBtn.disabled = false;
        } else {
          // Not broken - enable buttons based on current state
          
          // Start Session: only enabled if available (not in use)
          startBtn.disabled = !isAvailable;
          
          // End Session: only enabled if in use
          endBtn.disabled = !isInUse;
          
          // Report Malfunction: only enabled if no malfunction already reported
          reportMalfunctionBtn.disabled = hasMalfunction;
          
          // Fix Malfunction: only enabled if malfunction is reported
          fixMalfunctionBtn.disabled = !hasMalfunction;
          
          // Mark as Broken: always enabled when not broken
          markBrokenBtn.disabled = false;
          
          // Fix Broken Machine: only enabled when broken
          fixBrokenBtn.disabled = true;
        }
      } catch (error) {
        console.error('Error updating button states:', error);
        // On error, enable all buttons to prevent lockout
        startBtn.disabled = false;
        endBtn.disabled = false;
        reportMalfunctionBtn.disabled = false;
        fixMalfunctionBtn.disabled = false;
        markBrokenBtn.disabled = false;
        fixBrokenBtn.disabled = false;
      }
    }
    
    window.updateButtonStates = updateButtonStates;

    // Update statistics
    async function updateStats() {
      try {
        const { collection, getDocs } = window.firestoreModule;
        const equipmentRef = collection(window.db, 'equipment');
        const snapshot = await getDocs(equipmentRef);
        
        let total = 0;
        let active = 0;
        let available = 0;
        
        snapshot.forEach(doc => {
          const data = doc.data();
          total++;
          if (data.status === 'in_use') active++;
          if (data.status === 'available') available++;
        });
        
        document.getElementById('totalEquipment').textContent = total;
        document.getElementById('activeEquipment').textContent = active;
        document.getElementById('availableEquipment').textContent = available;
        
        log('Statistics updated');
      } catch (error) {
        log(`Error updating stats: ${error.message}`, 'error');
      }
    }

    window.updateStats = updateStats;

    // Start equipment session
    window.startEquipmentSession = async function() {
      const equipmentId = document.getElementById('equipmentSelect').value;
      if (!equipmentId) {
        log('Please select equipment first', 'error');
        return;
      }

      try {
        const { doc, updateDoc, serverTimestamp } = window.firestoreModule;
        const equipmentRef = doc(window.db, 'equipment', equipmentId);
        
        await updateDoc(equipmentRef, {
          status: 'in_use',
          currentUserId: 'demo-user',
          sessionStartTime: serverTimestamp()
        });
        
        log(`✅ Started session on equipment: ${equipmentId}`, 'success');
        await loadEquipment();
        await updateStats();
      } catch (error) {
        log(`❌ Error starting session: ${error.message}`, 'error');
      }
    };

    // End equipment session
    window.endEquipmentSession = async function() {
      const equipmentId = document.getElementById('equipmentSelect').value;
      if (!equipmentId) {
        log('Please select equipment first', 'error');
        return;
      }

      try {
        const { doc, updateDoc, serverTimestamp } = window.firestoreModule;
        const equipmentRef = doc(window.db, 'equipment', equipmentId);
        
        await updateDoc(equipmentRef, {
          status: 'available',
          currentUserId: null,
          sessionStartTime: null,
          lastUsedAt: serverTimestamp()
        });
        
        log(`✅ Ended session on equipment: ${equipmentId}`, 'success');
        await loadEquipment();
        await updateStats();
      } catch (error) {
        log(`❌ Error ending session: ${error.message}`, 'error');
      }
    };

    // Report malfunction
    window.reportMalfunction = async function() {
      console.log('reportMalfunction called');
      const equipmentId = document.getElementById('equipmentSelect').value;
      console.log('Selected equipment:', equipmentId);
      
      if (!equipmentId) {
        log('Please select equipment first', 'error');
        return;
      }

      try {
        const { doc, getDoc, updateDoc, serverTimestamp } = window.firestoreModule;
        const equipmentRef = doc(window.db, 'equipment', equipmentId);
        
        // Check if equipment is broken first
        const equipmentDoc = await getDoc(equipmentRef);
        if (!equipmentDoc.exists()) {
          log('Equipment not found', 'error');
          return;
        }

        const data = equipmentDoc.data();
        console.log('Equipment data:', data);
        
        if (data.status === 'broken') {
          console.log('Equipment is broken, cannot report malfunction');
          log('Cannot report malfunction on broken equipment. Fix it first.', 'error');
          return;
        }
        
        console.log('About to update with malfunction flag...');
        await updateDoc(equipmentRef, { 
          hasMalfunction: true,
          malfunctionReportedAt: serverTimestamp()
        });
        console.log('Update successful!');
        
        log(`⚠️ Reported malfunction for equipment: ${equipmentId}`, 'warning');
        await loadEquipment();
        await updateStats();
      } catch (error) {
        console.error('Full error:', error);
        log(`❌ Error reporting malfunction: ${error.message}`, 'error');
      }
    };

    // Fix malfunction
    window.fixMalfunction = async function() {
      const equipmentId = document.getElementById('equipmentSelect').value;
      if (!equipmentId) {
        log('Please select equipment first', 'error');
        return;
      }

      try {
        const { doc, getDoc, updateDoc, serverTimestamp } = window.firestoreModule;
        const equipmentRef = doc(window.db, 'equipment', equipmentId);
        
        // Check if equipment is broken first
        const equipmentDoc = await getDoc(equipmentRef);
        if (!equipmentDoc.exists()) {
          log('Equipment not found', 'error');
          return;
        }

        const data = equipmentDoc.data();
        if (data.status === 'broken') {
          log('Cannot fix malfunction on broken equipment. Use "Fix Broken Machine" instead.', 'error');
          return;
        }
        
        await updateDoc(equipmentRef, { 
          hasMalfunction: false,
          malfunctionReportedAt: null,
          malfunctionFixedAt: serverTimestamp()
        });
        
        log(`🔧 Fixed malfunction for equipment: ${equipmentId}`, 'success');
        await loadEquipment();
        await updateStats();
      } catch (error) {
        console.error('Full error:', error);
        log(`❌ Error fixing malfunction: ${error.message}`, 'error');
      }
    };

    // Mark as broken
    window.markAsBroken = async function() {
      const equipmentId = document.getElementById('equipmentSelect').value;
      if (!equipmentId) {
        log('Please select equipment first', 'error');
        return;
      }

      try {
        const { doc, updateDoc, serverTimestamp } = window.firestoreModule;
        const equipmentRef = doc(window.db, 'equipment', equipmentId);
        
        await updateDoc(equipmentRef, { 
          status: 'broken',
          currentUserId: null,
          sessionStartTime: null,
          brokenAt: serverTimestamp()
        });
        
        log(`❌ Marked equipment as broken: ${equipmentId}`, 'error');
        await loadEquipment();
        await updateStats();
      } catch (error) {
        log(`❌ Error marking as broken: ${error.message}`, 'error');
      }
    };

    // Fix broken machine
    window.fixBrokenMachine = async function() {
      const equipmentId = document.getElementById('equipmentSelect').value;
      if (!equipmentId) {
        log('Please select equipment first', 'error');
        return;
      }

      try {
        const { doc, updateDoc, serverTimestamp } = window.firestoreModule;
        const equipmentRef = doc(window.db, 'equipment', equipmentId);
        
        await updateDoc(equipmentRef, { 
          status: 'available',
          brokenAt: null,
          fixedAt: serverTimestamp(),
          hasMalfunction: false,
          malfunctionReportedAt: null
        });
        
        log(`✅ Fixed broken equipment: ${equipmentId} - fully restored to available`, 'success');
        await loadEquipment();
        await updateStats();
      } catch (error) {
        log(`❌ Error fixing broken equipment: ${error.message}`, 'error');
      }
    };

    // Refresh equipment list
    window.refreshEquipment = async function() {
      log('Refreshing equipment list...', 'info');
      await loadEquipment();
      await updateStats();
    };

    // Toggle all machines as used
    window.toggleAllMachinesUsed = async function() {
      log('Setting all machines to "in_use"...', 'info');
      
      try {
        const { collection, getDocs, doc, updateDoc, serverTimestamp } = window.firestoreModule;
        const equipmentRef = collection(window.db, 'equipment');
        const snapshot = await getDocs(equipmentRef);
        
        const promises = [];
        
        snapshot.forEach(docSnapshot => {
          const equipRef = doc(window.db, 'equipment', docSnapshot.id);
          promises.push(
            updateDoc(equipRef, {
              status: 'in_use',
              currentUserId: 'demo-user',
              sessionStartTime: serverTimestamp()
            })
          );
        });
        
        await Promise.all(promises);
        
        log(`✅ Set ${snapshot.size} machines to "in_use"`, 'success');
        await loadEquipment();
        await updateStats();
      } catch (error) {
        log(`❌ Error setting machines: ${error.message}`, 'error');
      }
    };

    // Clear all sessions
    window.clearAllSessions = async function() {
      log('Clearing all sessions...', 'info');
      
      try {
        const { collection, getDocs, doc, updateDoc, serverTimestamp } = window.firestoreModule;
        const equipmentRef = collection(window.db, 'equipment');
        const snapshot = await getDocs(equipmentRef);
        
        const promises = [];
        
        snapshot.forEach(docSnapshot => {
          const equipRef = doc(window.db, 'equipment', docSnapshot.id);
          promises.push(
            updateDoc(equipRef, {
              status: 'available',
              currentUserId: null,
              sessionStartTime: null,
              lastUsedAt: serverTimestamp()
            })
          );
        });
        
        await Promise.all(promises);
        
        log(`✅ Cleared ${snapshot.size} equipment sessions`, 'success');
        await loadEquipment();
        await updateStats();
      } catch (error) {
        log(`❌ Error clearing sessions: ${error.message}`, 'error');
      }
    };

    // ========== FRIENDS MANAGEMENT ==========

    // Helper function to get user by email
    async function getUserByEmail(email) {
      const { collection, query, where, getDocs } = window.firestoreModule;
      const usersRef = collection(window.db, 'users');
      const q = query(usersRef, where('email', '==', email.toLowerCase()));
      const snapshot = await getDocs(q);
      
      if (snapshot.empty) {
        return null;
      }
      
      const userData = snapshot.docs[0].data();
      return {
        id: snapshot.docs[0].id,
        name: userData.name,
        email: userData.email,
      };
    }

    // Create a friend request
    window.createFriendRequest = async function() {
      const user1Email = document.getElementById('friendUser1Email').value.trim();
      const user2Email = document.getElementById('friendUser2Email').value.trim();

      if (!user1Email || !user2Email) {
        log('Please fill in both email addresses', 'error');
        return;
      }

      try {
        const { collection, doc, setDoc, getDoc, serverTimestamp } = window.firestoreModule;
        
        // Get both users from email
        log('Looking up users...', 'info');
        const [user1, user2] = await Promise.all([
          getUserByEmail(user1Email),
          getUserByEmail(user2Email)
        ]);
        
        if (!user1) {
          log(`❌ User not found: ${user1Email}`, 'error');
          return;
        }
        
        if (!user2) {
          log(`❌ User not found: ${user2Email}`, 'error');
          return;
        }
        
        // Check if request already exists
        const existingDoc = await getDoc(doc(window.db, `users/${user2.id}/FriendRequestsIncoming`, user1.id));
        
        if (existingDoc.exists()) {
          log('⚠️ Friend request already exists', 'warning');
          return;
        }
        
        // Check if already friends
        const friendDoc = await getDoc(doc(window.db, `users/${user1.id}/Friends`, user2.id));
        if (friendDoc.exists()) {
          log('⚠️ Already friends', 'warning');
          return;
        }

        // Create friend request in user2's incoming requests
        await setDoc(doc(window.db, `users/${user2.id}/FriendRequestsIncoming`, user1.id), {
          fromUserId: user1.id,
          fromUserName: user1.name,
          fromUserEmail: user1.email,
          sentAt: serverTimestamp(),
        });

        log(`✅ Friend request created from ${user1.name} to ${user2.name}`, 'success');
      } catch (error) {
        log(`❌ Error creating friend request: ${error.message}`, 'error');
      }
    };

    // Accept all pending friend requests for User 2
    window.acceptAllPendingRequests = async function() {
      const user2Email = document.getElementById('friendUser2Email').value.trim();

      if (!user2Email) {
        log('Please enter User 2 email', 'error');
        return;
      }

      try {
        const { collection, getDocs, doc, setDoc, deleteDoc, getDoc, serverTimestamp } = window.firestoreModule;
        
        // Get user 2 from email
        log('Looking up user...', 'info');
        const user2 = await getUserByEmail(user2Email);
        
        if (!user2) {
          log(`❌ User not found: ${user2Email}`, 'error');
          return;
        }
        
        // Get all pending requests for user2
        const requestsRef = collection(window.db, `users/${user2.id}/FriendRequestsIncoming`);
        const snapshot = await getDocs(requestsRef);

        if (snapshot.empty) {
          log('No pending friend requests found', 'warning');
          return;
        }

        let acceptedCount = 0;

        for (const requestDoc of snapshot.docs) {
          const requestData = requestDoc.data();
          const fromUserId = requestDoc.id;
          
          // Get both users' info
          const fromUserDoc = await getDoc(doc(window.db, 'users', fromUserId));
          
          if (!fromUserDoc.exists()) continue;
          
          const fromUserData = fromUserDoc.data();
          
          // Add to both users' Friends collections
          await Promise.all([
            setDoc(doc(window.db, `users/${fromUserId}/Friends`, user2.id), {
              friendId: user2.id,
              friendName: user2.name,
              friendEmail: user2.email,
              addedAt: serverTimestamp(),
            }),
            setDoc(doc(window.db, `users/${user2.id}/Friends`, fromUserId), {
              friendId: fromUserId,
              friendName: fromUserData.name,
              friendEmail: fromUserData.email,
              addedAt: serverTimestamp(),
            }),
            // Delete the friend request
            deleteDoc(doc(window.db, `users/${user2.id}/FriendRequestsIncoming`, fromUserId)),
          ]);

          acceptedCount++;
        }

        log(`✅ Accepted ${acceptedCount} friend request(s)`, 'success');
      } catch (error) {
        log(`❌ Error accepting friend requests: ${error.message}`, 'error');
      }
    };

    // Make two users friends directly (skip request)
    window.makeFriendsDirectly = async function() {
      const user1Email = document.getElementById('friendUser1Email').value.trim();
      const user2Email = document.getElementById('friendUser2Email').value.trim();

      if (!user1Email || !user2Email) {
        log('Please fill in both email addresses', 'error');
        return;
      }

      try {
        const { doc, setDoc, serverTimestamp } = window.firestoreModule;
        
        // Get both users from email
        log('Looking up users...', 'info');
        const [user1, user2] = await Promise.all([
          getUserByEmail(user1Email),
          getUserByEmail(user2Email)
        ]);
        
        if (!user1) {
          log(`❌ User not found: ${user1Email}`, 'error');
          return;
        }
        
        if (!user2) {
          log(`❌ User not found: ${user2Email}`, 'error');
          return;
        }
        
        // Add to both users' Friends collections
        await Promise.all([
          setDoc(doc(window.db, `users/${user1.id}/Friends`, user2.id), {
            friendId: user2.id,
            friendName: user2.name,
            friendEmail: user2.email,
            addedAt: serverTimestamp(),
          }),
          setDoc(doc(window.db, `users/${user2.id}/Friends`, user1.id), {
            friendId: user1.id,
            friendName: user1.name,
            friendEmail: user1.email,
            addedAt: serverTimestamp(),
          }),
        ]);

        log(`✅ ${user1.name} and ${user2.name} are now friends!`, 'success');
      } catch (error) {
        log(`❌ Error making friends: ${error.message}`, 'error');
      }
    };

    // Clear all friend data
    window.clearAllFriendData = async function() {
      if (!confirm('Are you sure you want to delete ALL friend requests and friendships? This cannot be undone!')) {
        return;
      }

      try {
        const { collection, getDocs, deleteDoc, doc } = window.firestoreModule;
        
        const deletePromises = [];
        
        // Clear all users' Friends and FriendRequestsIncoming
        const usersRef = collection(window.db, 'users');
        const usersSnapshot = await getDocs(usersRef);
        
        for (const userDoc of usersSnapshot.docs) {
          // Clear Friends
          const friendsRef = collection(window.db, `users/${userDoc.id}/Friends`);
          const friendsSnapshot = await getDocs(friendsRef);
          
          friendsSnapshot.forEach(friendDoc => {
            deletePromises.push(deleteDoc(doc(window.db, `users/${userDoc.id}/Friends`, friendDoc.id)));
          });
          
          // Clear FriendRequestsIncoming
          const requestsRef = collection(window.db, `users/${userDoc.id}/FriendRequestsIncoming`);
          const requestsSnapshot = await getDocs(requestsRef);
          
          requestsSnapshot.forEach(requestDoc => {
            deletePromises.push(deleteDoc(doc(window.db, `users/${userDoc.id}/FriendRequestsIncoming`, requestDoc.id)));
          });
        }

        await Promise.all(deletePromises);
        
        log(`✅ Cleared all friend data (${deletePromises.length} documents)`, 'success');
      } catch (error) {
        log(`❌ Error clearing friend data: ${error.message}`, 'error');
      }
    };

    // ========== ACTIVITY FEED ==========

    // Post an activity
    window.postActivity = async function() {
      const userId = document.getElementById('activityUserId').value;
      const userName = document.getElementById('activityUserName').value;
      const type = document.getElementById('activityType').value;
      const description = document.getElementById('activityDescription').value;
      const duration = parseInt(document.getElementById('activityDuration').value) || null;

      if (!userId || !userName || !description) {
        log('Please fill in User ID, Name, and Description', 'error');
        return;
      }

      try {
        const { collection, addDoc, serverTimestamp } = window.firestoreModule;
        const activitiesRef = collection(window.db, 'activities');

        const activityData = {
          userId,
          userName,
          type,
          description,
          createdAt: serverTimestamp(),
        };

        if (duration) {
          activityData.duration = duration;
        }

        await addDoc(activitiesRef, activityData);
        
        log(`✅ Activity posted: ${description}`, 'success');
      } catch (error) {
        log(`❌ Error posting activity: ${error.message}`, 'error');
      }
    };

    // Generate sample activities
    window.generateSampleActivities = async function() {
      const userId = document.getElementById('activityUserId').value;
      const userName = document.getElementById('activityUserName').value;

      if (!userId || !userName) {
        log('Please enter User ID and Name first', 'error');
        return;
      }

      const sampleActivities = [
        { type: 'workout_completed', description: `${userName} completed a 30-min cardio session`, duration: 30 },
        { type: 'workout_completed', description: `${userName} finished strength training`, duration: 45 },
        { type: 'achievement_earned', description: `${userName} earned the "Early Bird" badge!` },
        { type: 'streak_milestone', description: `${userName} reached a 7-day workout streak! 🔥` },
        { type: 'workout_completed', description: `${userName} did a yoga session`, duration: 20 },
      ];

      try {
        const { collection, addDoc, serverTimestamp } = window.firestoreModule;
        const activitiesRef = collection(window.db, 'activities');

        for (const activity of sampleActivities) {
          const activityData = {
            userId,
            userName,
            type: activity.type,
            description: activity.description,
            createdAt: serverTimestamp(),
          };

          if (activity.duration) {
            activityData.duration = activity.duration;
          }

          await addDoc(activitiesRef, activityData);
        }

        log(`✅ Generated ${sampleActivities.length} sample activities`, 'success');
      } catch (error) {
        log(`❌ Error generating activities: ${error.message}`, 'error');
      }
    };

    // Clear all activities
    window.clearAllActivities = async function() {
      if (!confirm('Are you sure you want to delete ALL activities? This cannot be undone!')) {
        return;
      }

      try {
        const { collection, getDocs, deleteDoc, doc } = window.firestoreModule;
        const activitiesRef = collection(window.db, 'activities');
        const snapshot = await getDocs(activitiesRef);

        const deletePromises = [];
        snapshot.forEach(docSnapshot => {
          deletePromises.push(deleteDoc(doc(window.db, 'activities', docSnapshot.id)));
        });

        await Promise.all(deletePromises);
        
        log(`✅ Cleared ${snapshot.size} activities`, 'success');
      } catch (error) {
        log(`❌ Error clearing activities: ${error.message}`, 'error');
      }
    };

    // ========== WORKOUT SESSIONS MANAGEMENT ==========

    // Add a single workout session
    window.addWorkoutSession = async function() {
      const userId = document.getElementById('sessionUserId').value;
      const duration = parseInt(document.getElementById('sessionDuration').value);
      const equipmentId = document.getElementById('sessionEquipment').value;

      if (!userId) {
        log('Please enter a User ID (Firebase UID)', 'error');
        return;
      }

      if (!duration || duration <= 0) {
        log('Please enter a valid duration', 'error');
        return;
      }

      try {
        const { collection, doc, addDoc } = window.firestoreModule;
        // Sessions are stored as subcollection: users/{uid}/sessions
        const userDocRef = doc(window.db, 'users', userId);
        const sessionsRef = collection(userDocRef, 'sessions');
        
        const now = Date.now();
        const endTime = now + (duration * 60 * 1000);
        const sessionData = {
          startTime: now,
          endTime: endTime,
          equipmentId: equipmentId || 'manual_entry',
          durationMinutes: duration,
          createdAt: now
        };

        await addDoc(sessionsRef, sessionData);
        
        log(`✅ Added ${duration}-minute workout session for user ${userId}`, 'success');
      } catch (error) {
        log(`❌ Error adding session: ${error.message}`, 'error');
      }
    };

    // Add a week of workout sessions
    window.addWeekOfSessions = async function() {
      const userId = document.getElementById('sessionUserId').value;

      if (!userId) {
        log('Please enter a User ID (Firebase UID)', 'error');
        return;
      }

      try {
        const { collection, doc, addDoc } = window.firestoreModule;
        // Sessions are stored as subcollection: users/{uid}/sessions
        const userDocRef = doc(window.db, 'users', userId);
        const sessionsRef = collection(userDocRef, 'sessions');
        
        const now = Date.now();
        const dayMs = 24 * 60 * 60 * 1000;
        const duration = 30; // 30 minutes per session = 210 minutes total
        const equipment = ['treadmill_1', 'bike_1', 'weights_1', 'treadmill_2', 'bike_2', 'weights_2', 'yoga_1'];

        log('Adding 7 days of sessions (30 min each)...', 'info');

        for (let i = 0; i < 7; i++) {
          const sessionTime = now - (i * dayMs);
          
          const sessionData = {
            startTime: sessionTime,
            endTime: sessionTime + (duration * 60 * 1000),
            equipmentId: equipment[i],
            durationMinutes: duration,
            createdAt: sessionTime
          };

          await addDoc(sessionsRef, sessionData);
        }
        
        log(`✅ Added 7 workout sessions for user ${userId} (one per day)`, 'success');
      } catch (error) {
        log(`❌ Error adding sessions: ${error.message}`, 'error');
      }
    };

    // Clear all sessions for a user
    window.clearUserSessions = async function() {
      const userId = document.getElementById('sessionUserId').value;

      if (!userId) {
        log('Please enter a User ID (Firebase UID)', 'error');
        return;
      }

      if (!confirm(`Are you sure you want to delete ALL workout sessions for user ${userId}?`)) {
        return;
      }

      try {
        const { collection, doc, getDocs, deleteDoc } = window.firestoreModule;
        // Sessions are stored as subcollection: users/{uid}/sessions
        const userDocRef = doc(window.db, 'users', userId);
        const sessionsRef = collection(userDocRef, 'sessions');
        
        const snapshot = await getDocs(sessionsRef);
        
        if (snapshot.empty) {
          log(`No sessions found for user ${userId}`, 'info');
          return;
        }

        const promises = [];
        snapshot.forEach(docSnapshot => {
          const sessionRef = doc(userDocRef, 'sessions', docSnapshot.id);
          promises.push(deleteDoc(sessionRef));
        });

        await Promise.all(promises);
        
        log(`✅ Deleted ${snapshot.size} sessions for user ${userId}`, 'success');
      } catch (error) {
        log(`❌ Error clearing user sessions: ${error.message}`, 'error');
      }
    };
  </script>
</body>
</html>
